#!/usr/bin/env perl6

# Internally, we treat the module names as module names, '::' and all.
# But since they're really files externally, they have to be converted
# from paths to module names, and back again.

sub path-to-module-name($path) {
    $path.subst(/^'lib/'/, '').subst(/\.pm6?$/, '').subst('/', '::', :g);
}

sub module-name-to-path($module-name) {
    my $pm = 'lib/' ~ $module-name.subst('::', '/', :g) ~ '.pm';
    $pm ~~ :e ?? $pm !! $pm ~ '6';
}

# According to "Introduction to Algorithms" by Cormen et al., topological
# sort is just a depth-first search of a graph where you pay attention to
# the order in which you get done with a dfs-visit() for each node.

sub topo-sort(@modules, %dependencies) {
    my @order;
    sub dfs-visit($module) {
        %color_of{$module} = 'visited';
        for %dependencies{$module}.list -> $used {
            if %color_of{$used} eq 'not yet visited' {
                dfs-visit($used);
            }
        }
        push @order, $module;
    }
    @order;

    my %color_of = @modules X=> 'not yet visited';
    for @modules -> $module {
        if %color_of{$module} eq 'not yet visited' {
            dfs-visit($module);
        }
    }
}

# some utility functions

sub directory-of($file) {
    $file.subst(/ <-[/]>* $ /, '');
}

sub prefix($prefix, $str) {
    my $index = $str.index($prefix);
    return defined $index && $index == 0;
}


# Some poor sods still have projects running only on the old Rakudo alpha
# branch. This option is for them, so they won't have to hand-edit their
# Makefile after generating it. Of course, ufo is all about *removing*
# archaic pieces of culture, so let's work on converting things to Rakudo
# master, as well.

sub MAIN(Bool :$alpha) {
    my $binary = $alpha ?? 'alpha' !! 'perl6';
    if $alpha {
        note "Using 'alpha' as the Perl 6 binary. Please upgrade your code.";
    }

    my $cwd = qx[pwd].chomp;

    if 'lib' !~~ :e {
        note "lib/ doesn't exist. Nothing to do.";
        exit 1;
    }
    elsif 'lib' !~~ :d {
        note "lib isn't a directory. Nothing to do.";
        exit 1;
    }

    # The grep is needed because 'find' prints a final newline, so there'll be an
    # empty-string element at the end of the list.

    my @module-files = grep { $_ },
                    split "\n",
                    qx[find lib -name \*.pm -or -name \*.pm6];

    if !@module-files || @module-files[0].lc ~~ /'no such file'/ {
        note "Found no modules in lib/. Nothing to do.";
        exit 1;
    }

    # To know the best order of compilation, we build a dependency graph of
    # all the modules in lib/. %usages_of ends up containing a graph, with
    # the keys (containing names modules) being nodes, and the values
    # (containing arrays of names) denoting directed edges.

    my @modules = map { path-to-module-name($_) }, @module-files;
    my %usages_of;
    for @module-files -> $module-file {
        my $fh = open($module-file, :r);
        my $module = path-to-module-name($module-file);
        %usages_of{$module} = [];
        for $fh.lines() {
            if /^\s* 'use' \s+ (\w+ ['::' \w+]*)/ && $0 -> $used {
                next if $used eq 'v6';
                next if $used eq 'MONKEY_TYPING';

                %usages_of{$module}.push(~$used);
            }
        }
    }

    my @order = topo-sort(@modules, %usages_of);

    # The intended effect of the below loop is to put as many module paths on
    # each line as possible, breaking when necessary, and indenting nicely.

    my @sources = map { &module-name-to-path($_) }, @order;
    my $sources = 'SOURCES=';
    my $line-length = 0;
    for @sources -> $source {
        $line-length += $source.chars + 1;
        if $line-length > 65 {
                        # SOURCES=
            $sources ~= "\\\n        ";
            $line-length = $source.chars + 1;
        }
        $sources ~= $source ~ ' ';
    }
    $sources.=trim-trailing;

    my $makefile = open 'Makefile', :w;
    $makefile.say(qq[PERL6=$binary]);
    $makefile.say(qq[PERL6LIB='$cwd/lib']);
    $makefile.say(q[]);

    $makefile.say($sources);

    $makefile.say(qq[
PIRS=\$(patsubst %.pm6,%.pir,\$(SOURCES:.pm=.pir))

.PHONY: test clean

all: \$(PIRS)

%.pir: %.pm
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

%.pir: %.pm6
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

clean:
\trm -f \$(PIRS)

test: all
\tenv PERL6LIB=\$(PERL6LIB) prove -e '\$(PERL6)' -r --nocolor t/]);

    sub write-install($extension?) {
        my %dirs;
        # Find unique directory names and filter out only those who are not
        # prefixes of other directories.
        %dirs{$_} = 1 for @sources.map: { directory-of($^a) }
        # Lexicographic sort places prefixes before the string they are a
        # prefix of.
        my $prev = '';
        for %dirs.keys.sort -> $cur {
            $makefile.say: "\tmkdir -p ~/.perl6/$prev" if not prefix($prev, $cur);
            $prev = $cur;
        }
        $makefile.say: "\tmkdir -p ~/.perl6/$prev";

        for @sources -> $s {
            my $file = defined $extension
                        ?? $s.subst(rx{\.pm6?$}, '.' ~ $extension)
                        !! $s;
            # Can't use 'install -D' like we originally did, because Mac OS X
            # has that flag as '-d'.
            $makefile.say("\tinstall $file ~/.perl6/$file");
        }
    }

    $makefile.say(q[]);
    $makefile.say(q[install: all]);
    write-install('pir');

    $makefile.say(q[]);
    $makefile.say(q[install-src:]);
    write-install();
}

# vim: ft=perl6
