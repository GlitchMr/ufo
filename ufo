#!/usr/bin/env perl6

# Some poor sods still have projects running only on the old Rakudo alpha
# branch. This option is for them, so they won't have to hand-edit their
# Makefile after generating it. Of course, ufo is all about *removing*
# archaic pieces of culture, so let's work on converting things to Rakudo
# master, as well.

my $binary = 'perl6';
if @*ARGS == 1 && @*ARGS[0] eq '--alpha' {
    $binary = 'alpha';
    note "Using 'alpha' as the Perl 6 binary. Please upgrade your code.";
}
elsif @*ARGS {
    note "Usage: ufo [--alpha]";
    exit 1;
}

my $cwd = qx[pwd].chomp;

if 'lib' !~~ :e {
    note "lib/ doesn't exist. Nothing to do.";
    exit 1;
}
elsif 'lib' !~~ :d {
    note "lib isn't a directory. Nothing to do.";
    exit 1;
}

# The grep is needed because 'find' prints a final newline, so there'll be an
# empty-string element at the end of the list.

my @module-files = grep { $_ },
                   split "\n",
                   qx[find lib -name \*.pm -or -name \*.pm6];

if !@module-files
   || @module-files.elems == 1 && @module-files[0] ~~ /'no such file'/ {
    note "Found no modules in lib/. Nothing to do.";
    exit 1;
}

# To know the best order of compilation, we build a dependency graph of
# all the modules in lib/. %usages_of ends up containing a graph, with
# the keys (containing names modules) being nodes, and the values
# (containing arrays of names) denoting directed edges.

my @modules = map { path-to-module-name($_) }, @module-files;
my %usages_of;
for @module-files -> $module-file {
    my $fh = open($module-file, :r);
    my $module = path-to-module-name($module-file);
    %usages_of{$module} = [];
    for $fh.lines() {
        if /^\s* 'use' \s+ (\w+ ['::' \w+]*)/ && $0 -> $used {
            next if $used eq 'v6';
            next if $used eq 'MONKEY_TYPING';

            %usages_of{$module}.push(~$used);
        }
    }
}

# Internally, we treat the module names as module names, '::' and all.
# But since they're really files externally, they have to be converted
# from paths to module names, and back again.

sub path-to-module-name($path) {
    $path.subst(/^'lib/'/, '').subst(/\.pm6?$/, '').subst('/', '::', :g);
}

sub module-name-to-path($module-name) {
    my $pm = 'lib/' ~ $module-name.subst('::', '/', :g) ~ '.pm';
    $pm ~~ :e ?? $pm !! $pm ~ '6';
}

my @order;

# According to "Introduction to Algorithms" by Cormen et al., topological
# sort is just a depth-first search of a graph where you pay attention to
# the order in which you get done with a dfs-visit() for each node.

my %color_of = @modules X=> 'not yet visited';
for @modules -> $module {
    if %color_of{$module} eq 'not yet visited' {
        dfs-visit($module);
    }
}

sub dfs-visit($module) {
    %color_of{$module} = 'visited';
    for %usages_of{$module}.list -> $used {
        if %color_of{$used} eq 'not yet visited' {
            dfs-visit($used);
        }
    }
    push @order, $module;
}

# The intended effect of the below loop is to put as many module paths on
# each line as possible, breaking when necessary, and indenting nicely.

my @sources = map { &module-name-to-path($_) }, @order;
my $sources = 'SOURCES=';
my $line-length = 0;
for @sources -> $source {
    $line-length += $source.chars + 1;
    if $line-length > 65 {
                       # SOURCES=
        $sources ~= "\\\n        ";
        $line-length = $source.chars + 1;
    }
    $sources ~= $source ~ ' ';
}
$sources.=trim-trailing;

my $makefile = open 'Makefile', :w;
$makefile.say(qq[PERL6=$binary]);
$makefile.say(qq[PERL6LIB='$cwd/lib']);
$makefile.say(q[]);

$makefile.say($sources);

$makefile.say(qq[
PIRS=\$(patsubst %.pm6,%.pir,\$(SOURCES:.pm=.pir))

.PHONY: test clean

all: \$(PIRS)

%.pir: %.pm
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

%.pir: %.pm6
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

clean:
\trm -f \$(PIRS)

test: all
\tenv PERL6LIB=\$(PERL6LIB) prove -e '\$(PERL6)' -r --nocolor t/]);

sub directory-of($file) {
    $file.subst(/ '/' <-[/]>*? $ /, '');
}

sub write-install($extension?) {
    for @sources -> $s {
        my $file = defined $extension
                    ?? $s.subst(rx{\.pm6?$}, '.' ~ $extension)
                    !! $s;
        # Can't use 'install -D' like we originally did, because Mac OS X
        # has that flag as '-d'.
        my $directory = directory-of($file);
        $makefile.say("\tmkdir -p ~/.perl6/$directory");
        $makefile.say("\tinstall $file ~/.perl6/$file");
    }
}

$makefile.say(q[]);
$makefile.say(q[install: all]);
write-install('pir');

$makefile.say(q[]);
$makefile.say(q[install-src:]);
write-install();
