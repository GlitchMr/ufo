#!/usr/bin/env perl6

my $binary = 'perl6';
if @*ARGS == 1 && @*ARGS[0] eq '--alpha' {
    $binary = 'alpha';
    note "Using 'alpha' as the Perl 6 binary. Please upgrade your code.";
}
elsif @*ARGS {
    note "Usage: ufo [--alpha]";
    exit 1;
}

my $cwd = qx[pwd].chomp;

if 'lib' !~~ :e {
    note "lib/ doesn't exist. Nothing to do.";
    exit 1;
}
elsif 'lib' !~~ :d {
    note "lib isn't a directory. Nothing to do.";
    exit 1;
}

my @module-files = grep { $_ },
                   split "\n",
                   qx[find lib -name \*.pm -or -name \*.pm6];

if !@module-files
   || @module-files.elems == 1 && @module-files[0] ~~ /'no such file'/ {
    note "Found no modules in lib/. Nothing to do.";
    exit 1;
}

my @modules = map { path-to-module-name($_) }, @module-files;
my %usages_of;
for @module-files -> $module-file {
    my $fh = open($module-file, :r);
    my $module = path-to-module-name($module-file);
    for $fh.lines() {
        if /^\s* 'use' \s+ (\w+ ['::' \w+]*)/ && $0 -> $used {
            next if $used eq 'v6';
            next if $used eq 'MONKEY_TYPING';

            (%usages_of{$module} //= []).push($used);
        }
    }
}

sub path-to-module-name($path) {
    $path.subst(/^'lib/'/, '').subst(/\.pm6?$/, '').subst('/', '::', :g);
}

sub module-name-to-path($module-name) {
    my $pm = 'lib/' ~ $module-name.subst('::', '/', :g) ~ '.pm';
    $pm ~~ :e ?? $pm !! $pm ~ '6';
}

my @order;

# According to "Introduction to Algorithms" by Cormen et al., topological
# sort is just a depth-first search of a graph where you pay attention to
# the order in which you get done with a dfs-visit() for each node.
my %color_of = @modules X=> 'not yet visited';
for @modules -> $module {
    if %color_of{$module} eq 'not yet visited' {
        dfs-visit($module);
    }
}

sub dfs-visit($module) {
    %color_of{$module} = 'visited';
    for %usages_of{$module}.list -> $used {
        if %color_of{$used} eq 'not yet visited' {
            dfs-visit($used);
        }
    }
    push @order, $module;
}

my @sources = map { &module-name-to-path($_) }, @order;
my $sources = 'SOURCES=';
my $line-length = 0;
for @sources -> $source {
    $line-length += $source.chars + 1;
    if $line-length > 65 {
                       # SOURCES=
        $sources ~= "\\\n        ";
        $line-length = $source.chars + 1;
    }
    $sources ~= $source ~ ' ';
}
$sources.=trim-trailing;

my $makefile = open 'Makefile', :w;
$makefile.say(qq[PERL6=$binary]);
$makefile.say(qq[PERL6LIB='$cwd/lib']);
$makefile.say(q[]);

$makefile.say($sources);

$makefile.say(qq[
PIRS=\$(patsubst %.pm6,%.pir,\$(SOURCES:.pm=.pir))

all: \$(PIRS)

%.pir: %.pm
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

%.pir: %.pm6
\tenv PERL6LIB=\$(PERL6LIB) \$(PERL6) --target=pir --output=\$@ \$<

clean:
\trm -f \$(PIRS)

test: all
\tenv PERL6LIB=\$(PERL6LIB) prove -e '\$(PERL6)' -r --nocolor t/]);
